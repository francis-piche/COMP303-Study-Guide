\documentclass[12pt]{article}
\usepackage{amsmath,amsthm,amssymb,dsfont,polynom}
\usepackage[pdftex]{graphicx}

\graphicspath{{images/}}

\usepackage[margin = 1.0in]{geometry}
\usepackage{fancyhdr}
\usepackage{hyperref}
\pagestyle{fancy}
\lhead{Francis Pich\'e}

\thispagestyle{empty}


\newtheorem{problem}{Problem} 
\theoremstyle{definition} 
\newtheorem*{solution}{Solution}

\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language= Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}


\begin{document}
\title{COMP 303 Study guide}
\author{Francis Pich\'e}
\date{\today}
\maketitle
\newpage
\tableofcontents
\newpage

\part{Introduction}
\section{Disclaimer}
These notes are curated from Professor Joseph Vybihal's COMP303 lectures at McGill University. They are for study purposes only. They are not to be used for monetary gain.
\section{About This Guide}
I make my notes freely available for other students as a way to stay accountable for taking good notes. If you spot anything incorrect or unclear, don't hesitate to contact me via Facebook or e-mail at \url{http://francispiche.ca/contact/}
\part{Writing Good Code}
Good code is:
\begin{itemize}
	\item Optimal (Time complexity and memory)
	\item Simple
	\item Correct
	\item Robust (Few crashes, good error handling etc.)
	\item Easy to read
	\item Is well documented
	\item Uses accepted engineering techniques.
\end{itemize}
\section{Strategies for Writing Good Code}
\subsection{Optimality}
To minimize memory usage we could:
\begin{itemize}
	\item Encode long strings of data (compressing)
	\item Re-calulate instead of store values (trade-off with speed)
	\item Check library overhead!
	\item Data structure overhead (graph has a lot more pointers than a linked list!)
\end{itemize}
To minimize time complexity:
\begin{itemize}
	\item Come up with a better algorithm (Improve big O)
	\item Store more things in RAM (rather than in a DB or over a network)
	\item Avoid nesting of pointers
	\item Avoid deep or unnecessary recursion 
\end{itemize}
\subsection{Simplicity}
Strategies for simplicity:
\begin{itemize}
	\item Good variable names (avoid single letters except for array index's)
	\item Don't use lots of variables when an array is more appropriate
	\item Use simpler data structures if possible
	\item Reduce the volume of code
	\item Limit line length
	\item Modularize the program
	\item Use algorithms that are well known if possible
\end{itemize}
\subsection{Correctness}
The only way to be somewhat sure that your program is correct is through rigorous testing. Some things are easier to test than others, and theres entire QA departments that specialize in testing. But with the rise of Agile, more and more standard Devs need to be good at testing.
\\ \linebreak
Some general ideas on testing:
\begin{itemize}
	\item 1 test per 1 function
	\item Test valid inputs
	\item Test invalid inputs
	\item Test edge cases
	\item Validate that the output is correct
\end{itemize}
There's a ton of material online about testing and I definitely recommend taking some time to learn about more in-depth testing methods than what is covered in this course. It's required in almost all dev jobs and it's a very valuable skill to have.

\subsection{Readability}
This comes from good indentation, spacing and general style of code. Most people know this implicitly so I won't go into detail. For examples see the lecture slides from Lecture 2. 

\subsection{Comments as documentation}
The first place documentation happens is on the code level. This is where you can remove any ambiguity or sources of confusion from your code for other developers (or even future you). While real projects require real documentation, and excessive comments can be a detriment to readability, more comments are generally better than not enough. Break down your complex algorithms into comment separated steps, or add side-notes on anything that could be confusing to another developer.

\section{Well Designed Objects}
A well designed object should be one that does not cause any "wut?" moments amongst a team of developers. Specifically:
\begin{itemize}
	\item Single class per file
	\item Single purpose
	\item Expose only essential information
	\item Support an API structure
	\item Follow appropriate inheritance methods
\end{itemize}
\subsection{Single Purpose}
A class should be used to represent an idea, concept or object (pun-intended), and nothing more. A student should only contain ideas directly relevant to a student. A \texttt{Car} class should not have information about busses or trucks.
\\ \linebreak
This ensures that someone using your class can quickly find out everything there is to know about your object in an intuitive way. If your Student class has information about apples buried inside somewhere, someone on your team would have a hard time finding that out.
\subsection{Restriction of Information}
This is done to ensure that the class will be used correctly. There should be a decent amount of thought put into which parts of the code are "internal" and "external" to the class, ie: what parts of the class does the program need easy access to?
\\ \linebreak
Any time you use the \texttt{public} keyword, you should be thinking twice about if it's truly needed.
\subsection{Encapsulation}
When you take the concepts of single purpose and restriction of information and put them together, you get \textit{encapsulation}. Essentially what this means is that your class should be it's own complete bubble. No code outside the class should do the same things as inside your class, nor should things outside affect the class in an uncontrolled way.
\subsection{Inheritance}
To avoid duplication of code, we use inheritance to relate objects. This way classes can share common elements and simplify our lives. For details on inheritance see my COMP250 guide.
\\ \linebreak
Note that private information from a parent is not visible t the child.
\\ \linebreak
To design inheritance well:
\begin{itemize}
	\item A parent is more general
	\item A child is more specific
\end{itemize}
\subsection{Pre \& Post Conditions}
To keep things coherent, if a parent object imposes a condition on data, the child should maintain this condition. For example if a parent object has the condition that \texttt{salary} $>$ \texttt{0} then the child should not violate this by overriding the condition with say, negative values. It could, however, override it with \texttt{salary} $>$ \texttt{10000}.
\\ \linebreak
This is known as a \textbf{rich} starting point. Another example of a rich starting point is using a library, or some sample code.
\\ \linebreak
THis might be an issue since you may be inheriting, importing or implementing more features than are really needed.
\subsection{Extending vs Wrapping vs Interfaces}
Extending is when a new class contains the parent but adds extra methods and variables. Allows for polymorphism (see 250 guide for more on that). 
\\ \linebreak
Interfaces are used when the classes implementing are not necessarily related, but share common methods. For example the \texttt{Iterable} interface can be implemented by say, a \texttt{Degree} class, which contains a list of courses. But also a \texttt{Queue} class which has nothing to do with degrees or courses conceptually. So this allows for polymorphism across multiple inheritance trees.
\\ \linebreak
Wrapping is not a formal construct in a language, but it is the idea of placing objects inside a "wrapper" class, to put objects together in a more abstracted way.
\\ \linebreak
A special case is \texttt{abstract base classes}. These cannot be instantiated and contain both implemented and non-implemented methods. They provide the inheritance properties of extending, with the templating of interfaces. 

\section{Object Identity \& Lifecycle}
All objects have an idenity,(a reference or anonymous) and a lifecycle. Their lifecycle depends on the language and how they are handled (in C/C++ you have to manually free them from memory, vs garbage collection)
\subsection{Referenced Obects}
This is when an object is created by assigning its instance to a variable. \texttt{Object o = new Object()}. In this way, when no variables remain that point to this object, it is garbage collected (in Java) or causes a memory leak (C/C++).
\subsection{Anonymous Objects}
These are objects without references. For example \texttt{fn(new Object())}. It is then assigned a reference in the scope of the function, or in the scope of the Object to which it was passed into. For example if you pass an object into the constructor of another object, if it is then assigned to a variable in the second object, it will die with the object it is inside of.
\subsection{Static vs Instance}
A static object (or variable) can exist only once. That is, it cannot be instantiated. There can be no direct communication between static and instance structures.
\\ \linebreak
The \texttt{C} version of this would be in the two different ways of creating structs. One where you give your struct a name at the end, vs if you instantiate it afterwards.
\section{Object Class and Class Class}
All objects in Java extend the Object class. I went in-depth with this in my 250 guide, but I'll summarize here.
\\ \linebreak
There are a few important methods that the Object class has.
\begin{itemize}
	\item \texttt{toString()}
	\item \texttt{equals(Object o)}
	\item \texttt{hashCode()}
	\item \texttt{clone()}
\end{itemize}
\subsection{Object.toString()}
Automatically called by many functions such as print statements. Overwrite this to change the string representation of your object. By default, it stores the name of the object, and a unique hexedecimal identifier.
\subsection{Object.equals()}
Since the \texttt{==} operator only checks if the addresses are the same (for reference types), using it with reference types often has strange results. It is therefore necessary to override the \texttt{Object.equals()} method to specify what it means for two objects to be equal. Are their attributes equal?(This is the default) Etc. Note that the default will not look at nested Objects, so you must specify an equals method for complicated data structures.

\subsection{Object.hashCode()}
Hash data structures are only as good as their hash function. So if the default for your data type is really bad, so you'd have to implement your own hash function (override the hashCode() method.)

\subsection{Object.clone()}
The default clone makes a shallow copy by only cloning the references. (The contents of the original can be changed by the clone!!). A deep copy would be making a clone of all references and make them point to actual independent locations. This can be done with the clone() method.

\subsection{Type Inquiry}
This is the idea of testing what type a variable is. This is done using the \texttt{instanceof} operator. For example: \texttt{x isinstance Shape}.
\\ \linebreak
However, it does not check if it is exactly that type, it instead checks if \texttt{x} is part of the inheritance tree of Shape. We can use this to check if a cast will be successful.
\\ \linebreak
We can check for exact class matching with the \texttt{Object.getClass()} method. It returns an Object containing the type information for a class. This object contains the name, and a pointer to the superclass object. (The class object of it's parent).
\\ \linebreak
The Class class has some other useful methods such as \texttt{isArray()} and \texttt{getComponentType()} which 1) tests if the class is array, and 2) if it is, get the type of the components of the array.

\section{Reflection}
This is the practice of a program analyzing itself.
\\ \linebreak
The Class class we looked at is useful for reflection.
\\ \linebreak
We also have:
\begin{itemize}
	\item Class
	\item Package
	\item Field
	\item Method
	\item Constructor
	\item Array
\end{itemize}
Using these, we can get all the features of a class.
\begin{lstlisting}
Class super = Rectangle.class.getSuper();

Class[] interfaces = Rectangle.class.getInterfaces();

Package p = String.class.getPackage();

Field[] fields = Math.class.getDeclaredFields();
for (Field f: fields){
	if(Modifier.isStatic(f.getModifiers()))
}

Contstructor[] constructors = Rectangle.class.getDeclaredConstructors();

for(Constructor c: constructors){
	Class[] params = c.getParameterTypes(); // can be used on methods too!
Method m = PrintStream.class.getDeclaredMethod("println", String.class);
m.invoke(System.out, "Hello, world!"); //invoke is only for public methods
}

\end{lstlisting}
Note that we might get some errors with \texttt{getDeclaredMethod()} namely, \texttt{NoSuchMethodException},
\texttt{IllegalAccessException} , and 
\texttt{InvocationTargetException} 
\\ \linebreak
We can then use the \texttt{setAccessible(bool tf)} method on Fields to set the field to be able to modified. We can then use \texttt{set()} and \texttt{get()} on the fields.
\\ \linebreak
In this example, we'll resize an array:
\begin{lstlisting}
Object newA = Array.newInstance(a.getClass().getComponantType(), 2*Array.getLength(a) + 1);

System.arraycopy(a, 0, newA, 0, Array.getLength(a));

a = newA;
\end{lstlisting}

\section{Generic Types}
A generic type is instantiated when an actual type is substituted for the type-variable.
\\ \linebreak

\begin{lstlisting}
public class ArrayList<E>{
	public E get(int i){...}
}
\end{lstlisting}
If a type is used, it must always be the same for the same type variable. So if you give \texttt{E} a String, all references to \texttt{E} must be with a String.
\\ \linebreak
We can take this further, with extending. For example:
\begin{lstlisting}
public static <E, F extends E> void append(ArrayList<E> a, ArrayList<F> c){...}
\end{lstlisting}
So this would only allow types E and F if F extends E.
\\ \linebreak
Going \textit{even further} we can use wildcards like this:
\begin{lstlisting}
public static <E> void append(ArrayList<? super F> a, ArrayList<F> b, int count){...}
\end{lstlisting}
To say that anything which is a parent of F is valid.
\\ \linebreak
It's worth noting that all this stuff with generics is really just for the compiler and is an abstraction. The hardware doesn't care, and actually once the code is compiled, everything is an Object. Due to this, all Generics are just Objects when you try to do type inspection on them at runtime.
\\ \linebreak
Generics can't:
\begin{itemize}
	\item Throw or catch generic types.
	\item Use primitives
	\item Be static
	\item Be instantiated
	\item Mess up inheritance
\end{itemize}

\section{Specifications}
A specification is a written document from the designer to the programmer specifying the exact requirements for the project.
\\ \linebreak
They usually include:
\begin{itemize}
	\item User interface
	\item Input and Output
	\item Files and databases
	\item Objects, data structures, algorithms
	\item Features/functionality
	\item Menus, GUI's etc.
\end{itemize}
They are hard to write. They have to cover all cases, be clear, be what the client wants, and limiting assumptions.
\\ \linebreak
How can we use the compiler to enforce specifications?
\\ \linebreak
\subsection{Design by Contracts}
An interface can be used as a contract to enforce specifications.
\\ \linebreak 
Note that a class can implement multiple interfaces, and an interface can extend another interface.
\\ \linebreak
However this doesn't contain any information about how the methods should be implemented, this is what the document is for.
\\ \linebreak
When we do this, we could have something like \texttt{SomeInterface x = new SomeClassThatImplemented()}. The type of the variable dictates which methods can be called. (Methods that are in the class but not the interface cannot be accessed).

\section{Anonymous Objects and Classes}
As mentioned in a previous section, we can create objects without assigning them to a variable. This is useful for passing it into a method, which forces it to be garbage collected at the end of the method. Or, for passing into the constructor of another object, so that when the new object is destroyed, both will be destroyed.
\\ \linebreak
We can also write an anonymous class directly in the instantiation of an object!
\begin{lstlisting}
	
	Example<Object> ex = new Example<>(){
		public int compare(Example e1, Example e2){
			return e1.compareTo(e2)
		}
	}
\end{lstlisting}
When doing this, the class is tied to exactly one object. When the object is garbage collected, so is the class.
\\ \linebreak
Even crazier, we can make a method, which will generate new anonymous classes!
\begin{lstlisting}
public class Country{
	public static Comparator<Country> comparatorByName(){
		return new Comparator<Country>(){
			public int compare(Country c1, Country c2){
				return c1.getName().compareTo(c2.getName());
			}
		};
	}
}
\end{lstlisting}

\part{Aside: Swing GUI Programming}
I'll refrain from copy pasting the code from the slides here, but I'll do my best to provide the explanation that Prof. Vybihal gave in class.
\\ \linebreak

\section{Basic Structure}
The basic element of a GUI in swing as a \texttt{JFrame} object. This will cause the window to be displayed, and can be populated with elements.On this you can set a size, set a layout, (there are layout objects in Swing too, for example \texttt{GridLayout}). You can then add a listener to this frame to specify close, resize, minimize behaviors. (By implementing interfaces in an anonymous class).
\\ \linebreak
Next is the \texttt{JPanel} object. This is like the window, but is instead a canvas onto which elements are placed. This will be placed within the window. You can also give layouts to a panel, 
\\ \linebreak
To add buttons, we need to add listeners to our button elements. This is done by implementing the \texttt{actionPerformed} method. This method take an \texttt{ActionEvent} object which has information about the event. 
\\ \linebreak

\section{Object Truth \& Writing Good Classes}
Classes and objects represent a logical entity, and so must always stay consistent with the context of that entity. Put another way, they are an analogy to real things, and so must be consistent with the analogy. If we have a class Student, we expect it to behave and contain things that a Student would have. 
\\ \linebreak
Truth is the idea that the objects instantiated from a class are consistent with the analogy of the class.
\\ \linebreak
If we use setters, getter and mutators, we must ensure that they preserve truth.
\\ \linebreak

A class is\textbf{invariant} when all objects of the class are always in a valid state. 
\\ \linebreak
This may be broken for a moment in time \textbf{during} a "fix" to maintain this valid state.
\\ \linebreak

This idea is similar to that of \textbf{cohesion}, in which all methods of a class should belong to the same abstraction or analogy. If the class is for Students, it doesn't have anything else.
\\ \linebreak
We also need to find a balance with convenience, since too much cohesion can make the classes hard to use. For example, \texttt{pop()} is not only a pop. It also returns a value, so it's really a \texttt{peek()} and a \texttt{remove()}.
\\ \linebreak
We should also name and program in a way that is intuitive and consistent.

\section{Defensive Programming}
Always assume people are going to break your stuff. We must then validate all inputs and outputs.
\\ \linebreak
We do this using a \textbf{precondition} and \textbf{postcondition}. We use the precondition to test the inputs, do some work assuming everything is fine, and then validate the result at the end. Usually we can just use one, (usually preconditions because it saves work of doing the method).
\\ \linebreak
We throw exceptions when the expectation of the result is not obeyed. (If one of the conditions fails.) We only return if the result and inputs were valid. 

\part{Tools That Aid Good Design}
\section{Unit Testing}
A unit is a single "functioning unit", that is, it has no specific size or shape. It could be one method, a class, or collection of classes. We then cover this unit by handling all possible cases.
\\ \linebreak
We've already covered writing unit tests without tools in the earlier part of the course.
\\ \linebreak

\section{JUnit}
JUnit is a java framework for unit testing. It basically looks for classes and methods with the name "test" in them, and runs all your tests. 
\\ \linebreak
You would normally create a test class \texttt{DayTest} for example, that extends \texttt{TestCase}, a JUnit parent class. This parent class contains all the JUnit "stuff". 
\section{Javadoc}
The importance of documentation is self-evident. Javadoc is a tool that auto-generates an HTML file based on specially formatted comments in your code. They always begin with \texttt{/**} (rather than just /*). We then use the @ symbol to specify attributes. (for example: @author Francis Pich\'e, @return int) 
\\ \linebreak
Since it gets converted to HTML, you can actually inject html into the comments to add custom formatting!

\part{Modeling}

Software design is the idea of planning before coding. Abstractions and architecture are used to create a full model before beginning the implementation.
\\ \linebreak
The development (which would be done by the programmers) is controlled by the designer by using effective communication, strong OO constructs, and unit testing. The requirements are described by contracts, generalized code and UML (or some other modeling method). 
\\ \linebreak

\section{UML Class Diagrams}
This diagram describes all classes, data structures, objects and what they contain. 
\\ \linebreak
You could exhaustively go and model every possible attribute, method etc. But this is really hard to do since it's almost impossible for a designer to forsee every method a programmer would need, without writing anything himself. 
\\ \linebreak
In this class, we will make minimal diagrams, where we specify only the minimal variables and methods.
\\ \linebreak
You could also make hybrid responsibility diagrams, where instead of specifying methods you would write a "responsibility" description. (Not done in this course)
\\ \linebreak
A basic class would look like:
\\
\includegraphics{basic_class}
\\
Where the + means public and the - means private.
\\ \linebreak
\subsection{Relations}
Since classes often depend and use each other, we need a way to depict this.
\\ \linebreak
\begin{itemize}
	\item Association : class A calls a method in class B
	\item Inheritance : A extends B
	\item Realization / Implementation : A implements B  
	\item Dependency : A assumes something about B but doesn't use it directly.
	\item Aggregation : see below
	\item Composition : see below
	\item Undirected : Relation in an undefined way.
\end{itemize}
Aggregation and composition are a little weird to understand. (At least for me!) Class A aggregates class B, if class B can exist without the existence of class A. Meanwhile, Class A composes class B if class B cannot exist without being within class A. \url{https://www.visual-paradigm.com/guide/uml-unified-modeling-language/uml-aggregation-vs-composition/}
\\ \linebreak
These relationships are expressed with these arrows: (in order)\\
\includegraphics[scale=0.5]{arrows}
\\
Note that having TONS of arrows is probably a good indication of bad design.
\\ \linebreak
We can also express multiplicity by adding $n..m$ or $0..*$ etc. To show there should be between $n$ to $m$ instances, or $0$ to $\infty$ instances.
\\ \linebreak
\subsection{Examples}
\subsubsection{House}
	\includegraphics[]{house}
	\\
	The main method is most likely inside House, since most instantiations are coming out of house.
	\\ \linebreak
	In this picture, a House must have exactly 1 Kitchen, 1 Bathroom, and 1 to many Bedrooms. All of those extend Room. A Mortgage is somehow related, and can exist or not. A Mailbox is given to the house, but not necessarily part of it. (aggregation).
	\\ \linebreak
	There is actually a problem with this. Is Mailbox static? If not, then it must be instantiated by something. But this picture says it must be static, but it's also associated to the House using an aggregation, which means it must be instantiated.
	\\ \linebreak
	We could make this correct by adding another Main class which instantiates Mailbox (and possibly House if we don't want it to be static).
	\textbf{Always think of what needs to be instantiated!!!}

\subsubsection{University}
\includegraphics[]{university}
\\
Here we are adding labels to the associations. These describe what the relationship actually is. 
\\ \linebreak
Notice that Professor has no methods, since they aren't important and we are doing a hybrid responsibility here (even though we said we wouldn't do those!). Meanwhile, Enrollment has some methods since they are important to understanding the situation and requirements.
\\ \linebreak

\section{Sequence Diagram}
This is a use-case view of the system. Here we look at (in detail) what one part of the system will do in order. Very narrow and explicit.
\\ \linebreak
A class diagram does not explain the order (sequence) in which the program executes.
\\ \linebreak
In these we have a "timeline" representing execution flow, from left to right. The dotted lines coming down vertically break up the timeline into pieces by class. If the line is dotted the whole way down, the class is not executing, if there is a box, the class is executing. Solid arrows mean a method is being called, dotted arrows mean a value is being returned.
\\ \linebreak
We can add actors, who initiate the use cases.
\\ \linebreak
Loops and alternates are used to represent "for, while" and "or" (do not think about it as an if statement, since its not specified what the condition is.)
\\ \linebreak

\section{Activity Diagram}
Is essentially a flow chart of that the program should do. It can be for a single method, or a use case.
\\ \linebreak
This is more abstract and general than the sequence diagram, since it does not contain actual return values and methods, just plain words to describe whats happening.
\\ \linebreak
Note that there can be only one starting point, and can be many end points. 
\\ \linebreak
We can also make a multi-actor and object diagram, where we break up the diagram into columns of groups, and then individual actors. All actions regarding that actor fall within its column.

\part{Design Patterns}
The point of design patterns is to have a way of documenting language agnostic solutions to common software engineering problems. Often this is represented in UML.
\\ \linebreak
A design pattern contains:
\begin{itemize}
	\item Title
	\item Long description of the problem
	\item Full description of the solution using UML
\end{itemize}

\section{Composite Pattern}
From the wiki:
\\ \linebreak
"A part-whole hierarchy should be represented so that clients can treat the part and whole objects uniformly."
\\ \linebreak
Basically, one object contains a list of others which implement a common interface so that they can be called together.
\\ \linebreak
\includegraphics{composite}
\\
Here, both Leaf and Composite implement the Primitive interface. The method() of Composite simply calls the method() of all the Leaves which it contains. 
\\ \linebreak
This can be used to allow for individual Leaf objects to call method() by themselves, or be part of some greater Composite, and be called together.
\\ \linebreak
Example:
\begin{lstlisting}

class Team implements CompositeInterface{
	//Arraylist of CompositeInterface means we don't necessarily need all members of team to be same type
	//The deduct hitpoint could be different for each type of teammember
	private ArrayList<CompositeInterface> team = new ArrayList<>();
	
	//Call the deductHitPoint for each member of the team
	public void deductHitPoint(int n){
		for(T member : this.team){
			member.deductHitPoint(n);
		}
	}
}

//Same interface as the composite object (the Team)
class Soldier implements CompositeInterface{
	private float hp;
	public void deductHitPoint(int n){
		this.hp -= n;
	}
}

interface CompositeInterface{
	public void deductHitPoint(int n);
}
\end{lstlisting}


\section{Decorator Pattern}
\includegraphics{decorator}\\
\subsection{When is it used?}
The Decorator pattern is used when you have an object that cannot or should not be modified, but we want to add extra functionality to. 
\\ \linebreak
You might notice that the UML is very similar to the Composite, but there is only 1 Component in the Decorator composite object. 
\\ \linebreak

\subsection{How does it work?}
\begin{lstlisting}
class ExampleRunner{
	public static void main(){
		ConcreteComponent c = new ConcreteComponent();
		Decorator d = new Decorator();
		
		double random = Math.random()*10;
		if(random > 5){
			d.method();
		}else{
			c.method();
		}
	}

}

interface Component{
	public void method();
}

class ConcreteComponent implements Component{

	//Empty constructor for example
	public ConcreteComponent(){}
	
	//Implement the interface method
	public void method(){
		//Do stuff
	}
}

class Decorator implements Component{

	//Composed of exactly one Component
	Component c;
	
	//Notice the interface type being used, so we could decorate decorators easily too!
	Decorator(Component c){
		this.c = c;
	}
	
	//Decorator only works if you need not modify intermediate steps inside the method() of the ConcreteComponent. Must be able to just use end result.
	public void method(){
		this.c.method();
		//Do extra stuff 
	}
}
\end{lstlisting}

\subsection{Discussion}
We could also combine both the Decorator and Composite together. By having a 3rd class which implements the common interface, it could be composed of several Decorated (and non decorated) objects!
\\ \linebreak
Also, note that using inheritance instead of interfaces is not the same thing. In inheritance, we would only allow decorators in the same inheritance tree. We could not decorate two objects with the same decorator if those two objects are not in the same inheritance tree. This would lead us to only add functionality through evolution down the tree. 
We would also lose the reference to objects further along the inheritance tree, since we wouldn't have a direct reference to the base object. 
\\ \linebreak

\section{Iterator}
\includegraphics{iterator}\\
\subsection{When is it used?}
The Iterator can be used whenever we want to traverse across an object, independent of what the object is. It could be a LinkedList, ArrayList, Tree, Graph, etc. The iterator would work for all of them. So it is useful in cases when you don't necessarily know the datatype of what you'll be iterating over, or if you want to specify custom iteration behavior (for example BFS vs DFS on a Tree). 
\\ \linebreak
\subsection{How does it work?}
The client depends on both the Iterator interface and the Aggregate interface. They do not depend on eachother, but the client makes them work together through some control structure. The iterator interface always has the following methods:
\begin{itemize}
	\item next()
	\item hasNext()
	\item currentItem()
\end{itemize}
The Aggregate interface contains a \texttt{getIterator()} method.  We then need two classes. One implementing the Iterator interface, the other implementing the Aggregate. 
\\ \linebreak
Often, the iterator class will be nested and private inside the Aggregate class, then the way they are accessed from the client is by calling the getIterator() method from the Aggregator, and calling next() until hasNext() returns false. 

\begin{lstlisting}
	public interface Iterator{
		public Object next();
		public boolean hasNext();
		public Object currentItem();
	}
	
	public interface Aggregate{
		public Iterator getIterator();
	}
	
	public class ConcreteAggregate{
		//Some datastructure, doesn't matter which.
		private Tree<String> data = //Some data
		
		public Iterator getIterator(){
			return new ConcreteIterator();
		}
		
		//Private class to encapsulate the iterator.
		private class ConcreteIterator{
			TreeNode currentNode = data.root;
			
			//Just pseudocode
			@Override
			public boolean hasNext(){
				if(currentNode.children != null){
					return true;
				}
				return false;
			}
			
			@Override
			public TreeNode next(){
				if(this.hasNext()){
					//you get the idea
				}
				
				return null;
			}
		}
	}
	
	//Now we can easily iterate through without caring about the details.
	public ClientExample{
		public static void main(String[] args){
			ConcreteAggregate example = new ConcreteAggregate();
			
			for(Iterator iter = example.getIterator(); iter.hasNext;){
				//Do stuff
				TreeNode next = iter.next();
			}
			
			/*Note that in Java 8, you can use the enhanced for loop on anything that implements the iterator interface (built into Java).
			for(TreeNode t : example.getIterator())*/
		}
	}
\end{lstlisting}

\section{Singleton}
\includegraphics{singleton}
\subsection{When is it used?}
The Singleton is used when we want to ensure that only one instance of the class ever exists at one time.
\subsection{How does it work?}
To understand the Singleton, it's important to understand the \texttt{static} keyword in Java. By now you probably know that Java is built on C. Essentially, objects boil down to structs in C. The difference, then, between static and non-static is that static allows the thing to be created compile time only. (Cannot be malloced).
\\ \linebreak
We use this to ensure that only one instance of the singleton is created. 

\begin{lstlisting}
public class Singleton{

	//Notice the private static 
	private static SingleTon instance = null;
	
	//Hide the constructor
	private Singleton(){}
	
	//Controlled static access to the singleton
	public static Singleton getInstance(){

		//Only create the instance if it's the first time this is called.
		if(this.instance == null){
			this.instance = new Singleton();
		}
	
		return this.instance;
	}
	
}
\end{lstlisting}
So now, the compiler will give an error if anyone tries to do \texttt{Singleton singleton = new Singleton()} from outside the singleton class, since the constructor is private. 
\\ \linebreak
We can also use this to wrap other objects to make them singletons as well, by having them as a private class in the Singleton file. 

\section{MVC}
\includegraphics{mvc}\\
The Model View Controller is a \textbf{style} or set of similar design patterns that provide a solution to the same use-case. The idea is that most applications can be divided into three parts. The controller, model, and view. The controller is the interface between the User and the Model that, well, controls how data is updated. The Model is all the data, and the View is the visual representation of the data seen by the user.
\subsection{When is it used?}
This is used whenever the above described behavior is what describes your system. There can be many views, many controllers and many models. The ratio's between them are not always 1:1. We use this style when we want all of these things to be updated simultaneously. For example, a use presses a button. The controller updates the model data, and the view is updated to match the data. There could be multiple views for one model (think bar chart and pie chart for the same data), data may be manipulated by several controllers.
\\ \linebreak
The canonical example of this is the Java Swing library. 
ller will have an array list of  
\subsection{How does it work?}
Basically, the idea is just to separate the concepts into different classes. Your Controller class should only be responsible for:
\begin{itemize}
	\item Handling user input
	\item Updating the Model(s)
	\item Displaying the View(s)
\end{itemize}
To do this, normally the controller keeps a reference to the Model(s) and the View(s), and has a method for updating and displaiyng.
\begin{lstlisting}
class Model {
	//Data stuff
	
	//Could be different/more complex, this is just an example for simplicity.
	void update(){
	}
}

class View {
	//Visual stuff (printing, GUI, etc)
	
	void display(){
		//Do all the displaying
	}
}

class Controller{
	private Model m;
	private View v;
	
	
	//Update is the only method that the developer will have to call. This can take parameters if needed.
	void update(){
		m.update();
		v.display();	
	}
}
\end{lstlisting}
 
It is also common to see the controller and view together in one class, this is known as MVC1 (as opposed to MVC2 described previously). In this case,  it's more of a "interactive window" idea.
\\ \linebreak
Multiple models and views can be implemented using \textbf{registration}. The idea there, is that the Controller has instead a list of Models/ Views. "Registering" a view/model is just adding one to the Controller's list.
\\ \linebreak
We can also modify this so that the Model can notify the View of changes, rather than the controller managing this. This is known as MVC with \textbf{Notification}. In this way, the Controller only updates the Model, which then tells all relevant views to repaint themselves. In this one, the Views need to be registered with the Model, not the Controller. This way is often done with the Observer design pattern. 


\section{Observer}
\includegraphics{observer}
\subsection{When is it used?}
The Observer pattern is used whenever there is a one to many relationship in which a change in one object is to cause a notification in the relevant objects automatically.

\subsection{How does it work?}
The Subject class keeps a list of Observer objects (objects that implement Observer interface), and calls notify on all of them when a change is made to the Subject class. It also is responsible for handling attaching and detaching Observers from itself. Sometimes the Observers are an abstract class with a reference to the Subject, so they can attach themselves. Otherwise this is handled outside the pattern. 
\\ \linebreak
This is essentially what is happening with the MVC design pattern with notification. 


\section{Strategy}
\includegraphics{strategy}
\\
\subsection{When is it used?}
Suppose you have a class that could benefit from having several different implementations of similar logic.You want to do this in such a way that the implementation logic can be swapped out dynamically, with good encapsulation.
\\ \linebreak
Now, one could have a bunch of if-statements or a switch-statement to handle which to use, or we could use the Strategy pattern to implement better code.

\subsection{How does it work?}
Essentially, we have a Strategy interface which will be implemented by the different "Strategies" for solving a problem. In a LayoutManager, these would be the exact layouts, BorderLayout, FormLayout etc.
\\ \linebreak
Then, the Context class determines which one of these strategies is used, and how.
\\ \linebreak
For example, we could have an avatar which uses two different AI techniques (strategies) to implement it's decision making. These can be changed depending on the context.
\\ \linebreak
We could also combine the Strategy design pattern with itself, by having multiple interfaces that extend eachother.
\begin{lstlisting}
interface Behavior{
	void doAction();
}

interface Thinking extends Behavior{
	Behavior think();
}

class Strategy implements Thinking{
	Behavior b;
	
	Behavior think(){
		//Decide which behavior to do
		return b;
	}
	
	void doAction(){
		//Do crazy stuff
	}
}

class Avatar {
	Thinking thinker = new Strategy();
	public void doThink(){
		Behavior b = thinker.think();
		b.doAction();
	}
}
\end{lstlisting}
So there, the Strategy decides which Behavior to use, (assume there are several), and then this can be used by the avatar to complete the action.

\section{Template}
\includegraphics{template}
\subsection{When is it used?}
Say you have an algorithm that has many similar steps, but some that may vary in their implementation. How can we avoid duplicate code? 
\\ \linebreak

\subsection{How does it work?}
By using an abstract class, we can implement a template method, in which each step may or may not be unique. If it is unique to the implementation, then it should be declared abstract. Otherwise, it can be implemented in the abstract class.
\\ \linebreak
\begin{lstlisting}
abstract class ShoppingCart{
	bool makePayment(double amount){
		String info = paymentInfo();
		int ptr = connect(info);
		bool answer = pay(ptr, amount);
		return answer;
	}
	
	abstract String paymentInfo();
	abstract connect(String connectionInfo);
	abstract bool pay(int connectID, double amount);
}

\end{lstlisting}

\section{Visitor}
\includegraphics{visitor}

\subsection{When is it used?}
Suppose we want to modify (add methods) to classes of many different types without having to alter those classes too much.
\\ \linebreak
Easy! The Visitor pattern allows you to add a method (or several) to several classes by making those classes implement the Acceptor interface. Then, you specify the behavior of all your methods in the a class which extends visitor.

\subsection{How does it work?}

\begin{lstlisting}
interface Visitor{

	public double visit(SomeClass1 c1);
	public double visit(SomeClass2 c2);
	public double visit(SomeClass3 c3);
}

interface Acceptor{
	//This is the only change that will need to be made to your classes to make them work with visitor design pattern
	public double accept(Visitor v);
}

class ConcreteVisitor implements Visitor{
	public double visit(SomeClass1 c1){
		//Do something specific to SomeClass1
	}
	public double visit(SomeClass2 c2){
		//Do something specific to SomeClass2
	}
	public double visit(SomeClass3 c3){
		//Do something specific to SomeClass3
	}
}

class SomeClass1 extends Acceptor{
	
	//Some class stuff
	
	public double accept(Visitor visitor){
		visitor.visit(this); // Pass reference to yourself so the Visitor class knows what to do
	}

	
}

class SomeClass2 extends Acceptor{

	//Some class stuff
	public double accept(Visitor visitor){
		visitor.visit(this); // Pass reference to yourself so the Visitor class knows what to do
	}

}


\end{lstlisting}

The problem with this is that we need to know all of the classes which will need to extend the Acceptor interface. If there is a finite number of them then fine, but when we add a new class we need to remember to add it to the interfaces!

\section{Factory}
\includegraphics{factory}
\subsection{When is it used?}
Suppose we want to create an object at runtime, but we want to randomize the type of that object within a hierarchy. So if you have a bunch of Enemy classes that extend Enemy, say, and you want to generate a random type of enemy. The Factory is used to decide which enemy is created.
\\ \linebreak
Alternatively, you can generate classes which implement a common interface as well, rather that within a hierarchy. This can be useful when separating logical components, and when using in conjunction with other patterns. (Maybe generating a Strategy for example)
\\ \linebreak

\subsection{How does it work?}

\begin{lstlisting}
interface Factory{
	public Product factoryMethod();
}

interface Product{
	//Some interface, abstract class or class
}

class Prod1 implements Product{
	//Some stuff
}

class Prod2 implements Product{
	//Some other stuff
}

class EnemyFactory implements Factory{
	public Product factoryMethod(){
		double random = Math.random();
		return (random > 0.5)? new Prod1() : new Prod2(); 
	}
}
\end{lstlisting}


\section{Adapter}
NOT COVERED FOR FINAL

\section{Command}
NOT COVERED FOR FINAL

\part{Threads}

Java threads in 15 minutes or less. LETS DO IT.
\\ \linebreak
\section{Threads in General}
Parallel execution my dudes. Threads do that. They share all the same variables and memory though so be careful! Make sure you use proper exclusion techniques to elegantly deal with race conditions.
\\ \linebreak
Race condition: Something that can go bad if theres two things modifying it at the same time. Note that something as seemingly harmless as \texttt{i++} can lead to race conditions. (Think what is i++ doing at the assembler level. It's made up of a read, and a write. So if one thread writes while another tries to read, boom your i is corrupt). 
\subsection{Mutual Exclusion}
Dealing with race conditions always involves using locks.
\\ \linebreak
Basically, locks will allow one (or more, depending on how you set them up), threads to enter a section of code, but will block all others from entering until the lock is released. 
\\ \linebreak
How this is done in Java is below:

\section{Java Threads}
Apparently Java is nice for multithreading. Not that we would know, we never got practice in this course.
\\ \linebreak
In Java, if you want your class to be able to run as a thread, you have to extend the Runnable interface. Then, you implement the run() method in your class.
\\ \linebreak
When you're ready to start your program, call start(). It's good practice to have a try catch block in your run() method since the thread could get interrupted, so you want to catch InterruptedException. It's also good practice to call Thread.sleep(DELAY); to give other threads a chance to run (since Java threads have no preemption, if you know what that is. Otherwise don't worry about it). 
\\ \linebreak
You can kill your threads by calling t.interrupt(). This could cause an interrupted exception if the thread was inside a wait(), sleep() or join().

\subsection{Run vs Start}
Calling run() is usually a mistake, since it won't actually create a new thread of execution (ie, your program won't speed up). However, if for some reason you want to execute the code you wrote inside run() inside the current thread of execution, go for it ;).

\subsection{Java Locks}
The simplest way to lock a critical section is to use the ReentrantLock() in Java.
\begin{lstlisting}
ReentrantLock lock = new ReentrantLock();
lock.lock();
try{

}catch{//handle some error maybe
}finally{
	lock.unlock();
}
\end{lstlisting}

\subsection{Conditions}
Conditions are a way of extracting the Object monitor methods (if you don't know what monitors are then don't worry about it). Basically, they can be used to have conditional waits.
\begin{lstlisting}
class BoundedBuffer{
	pubic int size = 0;
	
	private Lock queueLock = new ReentrantLock();
	private Condition full = queueLock.newCondition();
	private Condition empty = queueLock.newCondition();
	
	public void add(E newValue){
		queueLock.lock();
		try{
			while(size == elemnts.length){
				full.await(); //Block any threads that try to add
			}
			elemnts.add(newValue);
			size++;
		}finally{
			queueLock.unlock();
		}		
	}
	
	public void remove(){
		queueLock.lock();
		try{
			while(size == 0){
				empty.await(); //Block any threads that try to add
			}
			full.signal(); //Wake up one sleeping thread.
			elemnts.add(newValue);
			size--;
		}finally{
			queueLock.unlock();
		}
	}
}

\end{lstlisting}

Not used in the above example is signalAll(); which wakes up ALL threads which are waiting on a condition.
\\ \linebreak
\subsection{Synchronized}
The Synchronized keyword in Java will implicitly lock your method so that no two threads can execute it at the same time.
\begin{lstlisting}
public void synchronized superFastProgram(){	//Non-static so only this instance is synchronized
	//sensitive stuff

}

public static void synchronized superFastProgram(){

} //Static so ALWAYS synchronized

public void doThing(){

	//Can synchronize single blocks
	synchronized(this){
		
	}
}
\end{lstlisting}

\subsection{join()}
Join is often really badly explained so lemme try to make it simple.
\\ \linebreak
In short, t.join() makes the thread which executed that line to wait until t.run() completes.
\\ \linebreak
So if you do:
\begin{lstlisting}

t1.start(); //Prints some stuff
System.out.println("banana");
\end{lstlisting}
You may end up seeing banana printed before the code of t1 can execute. To fix this:
\begin{lstlisting}
t1.start();

try{
	t1.join();
}catch(InterruptedException e){
}
System.out.println("banana");
\end{lstlisting}
This forces t1 to finish before the print can happen.
\\ \linebreak
This does not affect other threads started in the same level. Say you have two threads: t1, t2.

\begin{lstlisting}
t1.start();
t2.start();

try{
	t1.join()
}catch blaba

System.out.println("banana");
\end{lstlisting}
The banana gets printed after t1 finishes, but leaves no guarantee that t2 has finished.
 
\end{document}